"""
Streamlit Upload & Preprocessing Page for AutoDocx
--------------------------------------------------
Modern UI for uploading repos, previewing structure,
running AST-based preprocessing, and viewing code.

Features:
- Upload ZIP files from GitHub/Bitbucket
- Real-time progress indicators
- Code exploration
- AST-based analysis
- LLM-powered documentation generation
"""

import streamlit as st
from pathlib import Path
import time

from components.uploader import handle_uploaded_zip, handle_github_url
from utils.file_utils import list_repo_tree
from utils.ast_parser import parse_repo_ast, parse_repo_ast_structured
from utils.report_builder import build_prompt, generate_llm_report
from utils.pdf_utils import markdown_to_pdf_bytes
from utils.github_utils import check_git_installed, validate_github_url

PAGE_TITLE = "ðŸ“¦ Upload Repository"


def show():
    st.markdown("### 1) Upload repository")
    st.caption("Choose to upload a ZIP file or clone directly from GitHub.")

    # Create tabs for different upload methods
    tab1, tab2 = st.tabs(["ðŸ“ Upload ZIP", "ðŸ”— GitHub URL"])
    
    uploads_dir = Path("app/data/uploads")
    uploads_dir.mkdir(parents=True, exist_ok=True)
    
    # Initialize or retrieve from session state
    extract_path = None
    repo_name = None
    
    # Check if we have a repository loaded from session state
    if "uploaded_repo_path" in st.session_state:
        extract_path = Path(st.session_state["uploaded_repo_path"])
        if extract_path.exists():
            repo_name = extract_path.name
    
    # Tab 1: ZIP Upload
    with tab1:
        st.caption("Max size: 100 MB. We safely extract and prep it for analysis.")
        
        uploaded_file = st.file_uploader(
            "ðŸ“ Upload repository (.zip)",
            type=["zip"],
            accept_multiple_files=False,
            help="Drag and drop or click to upload your GitHub repo as a ZIP file.",
        )

        if uploaded_file:
            try:
                repo_name, extract_path = handle_uploaded_zip(uploaded_file, uploads_dir)
                extract_path = Path(extract_path)
                st.session_state["uploaded_repo_path"] = str(extract_path)
                st.session_state["uploaded_repo_name"] = repo_name
                st.success(f"Repository uploaded and extracted successfully: `{repo_name}`")
                st.rerun()
            except Exception as e:
                st.error(f"Error processing upload: {e}")
    
    # Tab 2: GitHub URL
    with tab2:
        st.caption("Directly clone from GitHub without downloading ZIP files.")
        
        # Check if git is installed
        git_installed, git_info = check_git_installed()
        if not git_installed:
            st.error(f"âš ï¸ {git_info}")
            st.info("Git is required for cloning repositories. Please install it from https://git-scm.com/")
        else:
            st.success(f"âœ“ {git_info}")
        
        # GitHub URL input
        col1, col2 = st.columns([4, 1])
        with col1:
            github_url = st.text_input(
                "GitHub Repository URL",
                placeholder="https://github.com/username/repository",
                help="Enter the full GitHub repository URL (e.g., https://github.com/user/repo)",
                key="github_url_input"
            )
        
        with col2:
            st.write("")  # Spacer for alignment
            st.write("")  # Spacer for alignment
            clone_button = st.button("Clone", type="primary", disabled=not git_installed, use_container_width=True)
        
        # Optional branch selection
        with st.expander("Advanced Options", expanded=False):
            branch_name = st.text_input(
                "Branch (optional)",
                placeholder="main",
                help="Leave empty to use the default branch"
            )
        
        # Example URLs
        with st.expander("Example URLs", expanded=False):
            st.code("https://github.com/openai/whisper")
            st.code("https://github.com/microsoft/vscode")
            st.code("https://github.com/facebook/react")
        
        # Clone repository when button is clicked
        if clone_button and github_url:
            # Validate URL
            is_valid, error_msg = validate_github_url(github_url)
            if not is_valid:
                st.error(f"âŒ {error_msg}")
            else:
                with st.spinner("Cloning repository... This may take a moment."):
                    try:
                        branch = branch_name.strip() if branch_name and branch_name.strip() else None
                        repo_name, extract_path = handle_github_url(
                            github_url,
                            uploads_dir,
                        # Store in session state for persistence across reruns
                        st.session_state["uploaded_repo_path"] = str(extract_path)
                        st.session_state["uploaded_repo_name"] = repo_name
                        st.success(f"âœ… Repository cloned successfully: `{repo_name}`")
                        st.balloons()
                        # Force rerun to show the analysis sections
                        st.rerun
                        extract_path = Path(extract_path)
                        st.success(f"âœ… Repository cloned successfully: `{repo_name}`")
                        st.balloons()
                    except Exception as e:
                        st.error(f"âŒ Error cloning repository: {e}")
               success message with repo name
        if repo_name:
            st.info(f"ðŸ“¦ Currently loaded: **{repo_name}**")
        
        # Add option to clear/reset
        col_clear1, col_clear2 = st.columns([3, 1])
        with col_clear2:
            if st.button("ðŸ”„ Load Different Repo", use_container_width=True):
                if "uploaded_repo_path" in st.session_state:
                    del st.session_state["uploaded_repo_path"]
                if "uploaded_repo_name" in st.session_state:
                    del st.session_state["uploaded_repo_name"]
                if "parsed_results" in st.session_state:
                    del st.session_state["parsed_results"]
                if "parsed_structured" in st.session_state:
                    del st.session_state["parsed_structured"]
                st.rerun()
        
        # Show repository structure
        with st.expander("Repository structure", expanded=False):
            tree = list_repo_tree((extract_path), max_entries=300)
            st.code("\n".join(tree), language="bash"
            tree = list_repo_tree((extract_path), max_entries=300)
            st.code("\n".join(tree), language="bash")

        # Store repo path
        st.session_state["uploaded_repo_path"] = str(extract_path)

        # --- File viewer dropdown ---
        st.markdown("### 2) Explore code files")
        st.caption("Quickly preview any supported source file.")

        # Find all supported code files
        code_extensions = [".py", ".js", ".jsx", ".ts", ".tsx", ".java", ".go", ".rs", ".cpp", ".c", ".cs"]
        code_files = []
        for ext in code_extensions:
            code_files.extend(list(extract_path.rglob(f"*{ext}")))
        
        if code_files:
            file_options = [str(f.relative_to(extract_path)) for f in code_files]
            selected_file = st.selectbox(
                "Select a file to view its code:",
                file_options,
                help=f"Found {len(code_files)} code files in the repository"
            )

            if selected_file:
                try:
                    file_path = extract_path / selected_file
                    file_size = file_path.stat().st_size
                    
                    # Show file metadata
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("File Size", f"{file_size / 1024:.2f} KB")
                    with col2:
                        st.metric("Language", file_path.suffix[1:].upper() if file_path.suffix else "Unknown")
                    with col3:
                        st.metric("Total Files", len(code_files))
                    
                    # Determine language for syntax highlighting
                    lang_map = {
                        ".py": "python", ".js": "javascript", ".jsx": "javascript",
                        ".ts": "typescript", ".tsx": "typescript", ".java": "java",
                        ".go": "go", ".rs": "rust", ".cpp": "cpp", ".c": "c", ".cs": "csharp"
                    }
                    lang = lang_map.get(file_path.suffix.lower(), "text")
                    
                    # Read and display file content
                    max_file_size = 500 * 1024  # 500 KB limit for display
                    if file_size > max_file_size:
                        st.warning(f"File is large ({file_size / 1024:.1f} KB). Showing first 500 KB only.")
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                            content = f.read(max_file_size)
                    else:
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                            content = f.read()
                    
                    st.code(content, language=lang)
                except Exception as e:
                    st.error(f"âš ï¸ Could not load file: {e}")
        else:
            st.warning("No supported code files found in the uploaded repository.")

        # --- Preprocessing section ---
        st.markdown("### 3) Run code analysis")
        st.caption("We scan a subset of files to extract structure, languages, and dependencies.")

        col1, col2 = st.columns(2)
        with col1:
            max_files_input = st.number_input(
                "Max files to analyze",
                min_value=50,
                max_value=500,
                value=200,
                step=50,
                help="Limit the number of files to analyze (for performance)"
            )
        
        if st.button("Start AST Parsing", type="primary", use_container_width=True):
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            status_text.info("Preprocessing started â€” running AST parsing and language detection...")
            progress_bar.progress(10)

            try:
                status_text.info("Scanning repository structure...")
                progress_bar.progress(30)
                
                results = parse_repo_ast(str(extract_path), max_files=max_files_input)
                progress_bar.progress(60)

                if not results:
                    st.warning("No supported code files found in this repository.")
                    progress_bar.progress(100)
                else:
                    status_text.info("Parsing complete! Generating summary...")
                    progress_bar.progress(80)
                    
                    total_files = len(results)
                    st.success(f"Analysis complete! {total_files} files analyzed.")
                    progress_bar.progress(100)
                    
                    # Store results in session state
                    st.session_state["parsed_results"] = results
                    st.session_state["parsed_structured"] = None  # Will be generated if needed

                    # Display statistics
                    with st.expander("Analysis Summary", expanded=True):
                        st.metric("Files Analyzed", total_files)
                        
                        # Count languages
                        languages = {}
                        for item in results:
                            if "Language:" in item:
                                lang = item.split("Language:")[1].strip().split()[0]
                                languages[lang] = languages.get(lang, 0) + 1
                        
                        if languages:
                            st.write("**Language Distribution:**")
                            for lang, count in sorted(languages.items(), key=lambda x: x[1], reverse=True):
                                st.write(f"- {lang}: {count} files")

                    with st.expander("View Parsed Files (Top 15)", expanded=False):
                        for item in results[:15]:
                            st.markdown(f"```\n{item}\n```")
                        if len(results) > 15:
                            st.caption(f"... and {len(results) - 15} more files")

                    status_text.success("Parsed file summary generated successfully â€” ready for documentation generation!")
                    progress_bar.empty()
            except Exception as e:
                st.error(f"Error during parsing: {e}")
                import traceback
                with st.expander("Error Details"):
                    st.code(traceback.format_exc())
                progress_bar.empty()

        st.markdown("### 4) Generate documentation")

        if st.button("Generate AI-Powered Report", type="primary", use_container_width=True):
            progress_bar = st.progress(0)
            status_text = st.empty()

            status_text.info("Collecting repository context for LLM...")
            progress_bar.progress(20)

            try:
                if "parsed_structured" not in st.session_state or st.session_state["parsed_structured"] is None:
                    parsed_struct = parse_repo_ast_structured(str(extract_path), max_files=max_files_input)
                    st.session_state["parsed_structured"] = parsed_struct
                else:
                    parsed_struct = st.session_state["parsed_structured"]

                progress_bar.progress(40)
                status_text.info("Building comprehensive prompt...")
                prompt = build_prompt(parsed_struct)
                progress_bar.progress(60)

                if parsed_struct and prompt:
                    status_text.info("Calling LLM to generate documentation...")
                    progress_bar.progress(80)

                    report_md = generate_llm_report(prompt)
                    progress_bar.progress(100)

                    st.success("AI-powered report generated successfully!")
                    st.markdown(report_md)

                    # Prepare PDF bytes from markdown
                    try:
                        pdf_bytes = markdown_to_pdf_bytes(
                            report_md,
                            title=f"{extract_path.name} - AutoDocx AI Documentation"
                        )
                    except Exception as pdf_err:
                        pdf_bytes = None
                        st.warning(f"Could not generate PDF version: {pdf_err}")

                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.download_button(
                            label="Download Report (Markdown)",
                            data=report_md,
                            file_name=f"{extract_path.name}_ai_documentation.md",
                            mime="text/markdown",
                            use_container_width=True
                        )
                    with col2:
                        st.download_button(
                            label="Download Report (PDF)",
                            data=pdf_bytes if pdf_bytes is not None else b"",
                            file_name=f"{extract_path.name}_ai_documentation.pdf",
                            mime="application/pdf",
                            use_container_width=True,
                            disabled=pdf_bytes is None
                        )
                    with col3:
                        # Option to view prompt (for debugging)
                        with st.expander("View Prompt"):
                            st.code(prompt[:2000] + "..." if len(prompt) > 2000 else prompt)

                    progress_bar.empty()
                    status_text.empty()
                else:
                    st.error("Failed to prepare report data.")
            except RuntimeError as e:
                st.error(f"{str(e)}")
                st.info("Tip: Make sure you have set OPENAI_API_KEY in your environment variables.")
            except Exception as e:
                st.error(f"LLM report generation failed: {e}")
                import traceback
                with st.expander("Error Details"):
                    st.code(traceback.format_exc())
            finally:
                progress_bar.empty()
                status_text.empty()
    
    else:
        st.info("Please upload a `.zip` file or provide a GitHub URL to get started.")
